assert = require \assert
{EventEmitter} = require \events
Bot = require \./bot
Human = require \./human
send = require \./db/send
_ = require \./_
genCube = require \./generate/cube
genPack = require \./generate/pack
Cards = require \../data/cards
Sets = require \../data/sets

HOUR = 1e3 * 60 * 60
drafts = {}

transformCube = ({list, cards, packs}, type, seats) ->
  bad = []
  list = for name of list
    name .= trim!toLowerCase!
      .replace /^1.?\s*/ ''
      .replace /\s*\/+\s*/g ' // '
      .replace /[æâàáéíöúû]/g ->
        switch it
        case \æ => \ae
        case \â \à \á => \a
        case \é => \e
        case \í => \i
        case \ö => \o
        case \ú \û => \u
    if not name
      continue # skip blank lines
    if name not in Cards
      bad.push name
    name

  min =
    if type is \cube_draft
      seats * cards * packs
    else
      seats * 90

  unless min <= list.length <= 1e3
    throw Error "this cube needs between #{min} and 1000 cards; it has #{list.length}"

  if bad.length
    joined = bad.splice(-10).join '; '
    str = "invalid cards: #{joined}"
    if bad.length
      str += "; and #{that} more"
    throw Error str
  list

do decrement = ->
  for id, d in drafts
    for p of d.players
      if p.time and !--p.time
        p.autopick!
  setTimeout decrement, 1e3

class Draft extends EventEmitter
  ({cube, host, seats, sets, type}) ->
    assert type of <[ cube_draft cube_sealed draft sealed ]>, 'game type'
    assert 1 <= seats <= 8, \seats
    assert typeof host is \string 'typeof host'
    if type of <[ cube_draft cube_sealed ]>
      assert !sets, 'cube and not sets'
      assert typeof cube is \object 'typeof cube'
      {list, cards, packs} = cube
      assert list instanceof Array, 'typeof cube list'
      assert typeof cards is \number, 'typeof cube cards'
      assert typeof packs is \number, 'typeof cube packs'
      assert 8 <= cards <= 15, 'cards range'
      assert 3 <= packs <= 5,  'packs range'

      cube.list = transformCube cube, type, seats
      title = type
    else
      assert !cube, 'draft and not cube'
      assert sets instanceof Array, 'typeof sets'
      n = if type is \draft then 3 else 6
      assert sets.length is n, 'sets length'
      for set of sets
        assert set in Sets, 'set in Sets'
      title = sets * ' / '

    @ <<<< { cube, host, seats, sets, type, title }
    @ <<<<
      id: _.uid!
      players: []
      startTime: Date.now! / 1e3 | 0
      timeout: setTimeout @end.bind(@, \timeout), HOUR

  delta: -1
  state: \open

  join: (sock) ->
    {id} = sock
    for p of @players
      if p.id is id
        if p.dropped
          p.send \error 'you were dropped'
          return
        p.attach sock
        p.send \set @{ state, title }
        @meta!
        return

    unless @state is \open
      return sock.send \error 'draft started'

    if @players.length is @seats
      return sock.send \error 'draft full'

    h = new Human sock, sock.id is @host

    h.on \meta @~meta
    h.on \drop @~drop
    h.on \getCap @~getCap

    if h.isHost
      h.once \start (@addBots) ~>
        @start!

    h.send \set @{ title }
    @add h
    @meta!

  add: (p) ->
    @players.push p
    p.on \pass @~pass

  drop: (h) ->
    return unless @state is \open

    h.removeAllListeners!
    @players = _.without <>, h
    @meta!

  send: !(name, args) ->
    for p of @players
      p.send name, args

  meta: !->
    # TODO only send time + packs
    players = for p of @players
      { p.dropped, p.hash, p.name, p.time, packs: p.packs.length }
    for p, i of @players
      p.send \set { players, self: i }

  start: ->
    @state = \started
    clearTimeout @timeout
    @timeout = setTimeout @end.bind(@, \timeout), HOUR

    if @type is \sealed
      @state = \done
      for p of @players
        cards = genPack 1, @sets
        cards = _.flat <>
        p.cards = cards
        p.send \set { (p.zone): cards, @state }
      return

    if @type is \cube_sealed
      @state = \done
      cube =
        list: @cube.list
        cards: 15
        packs: 3
      packs = genCube @players.length * 2, cube
      for p of @players
        cards = packs.splice -6
        cards = _.flat <>
        p.cards = cards
        p.send \set { (p.zone): cards, @state }
      return

    drafts[@id] = @

    if @addBots
      while @players.length < @seats
        @add new Bot

    _.shuffle @players

    for p, i of @players
      p.index = i

    @packs =
      if @cube
        genCube @players.length, that
      else
        genPack @players.length, @sets

    @startRound!
    @meta!

  startRound: !->
    unless @packs.length
      return @end!

    @delta *= -1
    @activePacks = @players.length

    for p of @players
      p.startRound!
      p.receive @packs.pop!

  pass: (pack, index) ->
    player = _.at @players, index + @delta

    if pack.length
      player.receive pack
    else if !--@activePacks
      @startRound!

    # TODO ignore bot, dropped passes
    @meta!

  getCap: (p) ->
    return unless @state is \done
    if @type of <[ sealed cube_sealed ]>
      p.send \set { cap: 'not available for sealed' }
      return

    s = ''
    delta = -1
    # regenerate packs by looping over player picks
    for PACK til p.picks.length
      delta *= -1
      for PICK til p.picks[PACK]length
        s += "#{PACK + 1}, #{PICK + 1}\n"
        playerIndex = p.index
        cardIndex = PICK
        cards = []
        while card = _.at(@players, playerIndex)picks[PACK][cardIndex++]
          cards.push card.name
          playerIndex += delta
        cards.0 = '* ' + <>
        s += cards.sort!join \\n
        s += '\n\n'
    p.send \set { cap: s }

  end: (err) ->
    clearTimeout @timeout
    delete drafts[@id]
    @state = \done

    if err
      @emit \end
      @send \error err
      return
    @send \set { @state }

    setTimeout (~> @emit \end), HOUR

    return unless @sets

    data =
      start: @startTime
      end: Date.now! / 1e3 | 0
      sets: @sets

    data.players = for p of @players
      p{ isBot, picks }

    send data

module.exports = Draft
